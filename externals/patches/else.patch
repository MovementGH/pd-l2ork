diff --git a/Source/Audio/numbox~.c b/Source/Audio/numbox~.c
index c1aee6fc..89edaa37 100644
--- a/Source/Audio/numbox~.c
+++ b/Source/Audio/numbox~.c
@@ -230,8 +230,12 @@ static void numbox_range(t_numbox *x, t_floatarg f1, t_floatarg f2){
 }
 
 // ------------------------ widgetbehaviour-----------------------------
+#ifdef PDL2ORK
+static void numbox_key(void *z, t_floatarg fkey){
+#else
 static void numbox_key(void *z, t_symbol *keysym, t_floatarg fkey){
     keysym = NULL; // unused, avoid warning
+#endif
     t_numbox *x = z;
     char c = fkey, buf[3];
     buf[1] = 0;
diff --git a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h
index 21dc029b..7561af55 100644
--- a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h
+++ b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h
@@ -391,13 +391,21 @@ class AtomicQueue2 : public AtomicQueueCommon<AtomicQueue2<T, SIZE, MINIMIZE_CON
 
     T do_pop(unsigned tail) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(tail % size_);
+#ifdef PDL2ORK
+        return Base::do_pop_any(states_[index], elements_[index]);
+#else
         return Base::template do_pop_any(states_[index], elements_[index]);
+#endif
     }
 
     template<class U>
     void do_push(U&& element, unsigned head) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(head % size_);
+#ifdef PDL2ORK
+        Base::do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#else
         Base::template do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#endif
     }
 
 public:
@@ -519,13 +527,21 @@ class AtomicQueueB2 : public AtomicQueueCommon<AtomicQueueB2<T, A, MAXIMIZE_THRO
 
     T do_pop(unsigned tail) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(tail & (size_ - 1));
+#ifdef PDL2ORK
+        return Base::do_pop_any(states_[index], elements_[index]);
+#else
         return Base::template do_pop_any(states_[index], elements_[index]);
+#endif
     }
 
     template<class U>
     void do_push(U&& element, unsigned head) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(head & (size_ - 1));
+#ifdef PDL2ORK
+        Base::do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#else
         Base::template do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#endif
     }
 
 public:
diff --git a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h
index a279dcf8..35e72846 100644
--- a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h
+++ b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h
@@ -36,6 +36,15 @@ static inline void spin_loop_pause() noexcept {
 #endif
 }
 } // namespace atomic_queue
+#elif defined(__EMSCRIPTEN__)
+#include <emscripten.h>
+namespace atomic_queue {
+constexpr int CACHE_LINE_SIZE = 64;
+static inline void spin_loop_pause() noexcept {
+    // Yield to allow other pthreads in WebAssembly to run.
+    emscripten_sleep(0);
+}
+} // namespace atomic_queue
 #else
 #error "Unknown CPU architecture."
 #endif
diff --git a/Source/Shared/ffmpeg/build_ffmpeg.sh b/Source/Shared/ffmpeg/build_ffmpeg.sh
index 20ea0216..9f0a1281 100755
--- a/Source/Shared/ffmpeg/build_ffmpeg.sh
+++ b/Source/Shared/ffmpeg/build_ffmpeg.sh
@@ -17,7 +17,7 @@ elif [[ "$OS" == "Linux" ]]; then
         ffmpeg_config="--enable-openssl --enable-pic"
         ffmpeg_cc="${CC:-gcc}"
     fi
-elif [ "$(expr substr $(uname -s) 1 10)" == "MINGW64_NT" ]; then
+elif [ "$(expr substr $(uname -s) 1 5)" == "MINGW" ]; then
     ffmpeg_cc="${CC:-gcc}"
 else
     echo "Unsupported OS: $OS"
diff --git a/Source/Shared/link/udp/udp_socket.hpp b/Source/Shared/link/udp/udp_socket.hpp
index 2e447d2a..ab37ef80 100644
--- a/Source/Shared/link/udp/udp_socket.hpp
+++ b/Source/Shared/link/udp/udp_socket.hpp
@@ -11,7 +11,9 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #undef min
+#ifndef PDL2ORK
 typedef SSIZE_T ssize_t;
+#endif
 // Unix
 #else
 #include <sys/types.h>
diff --git a/Source/Audio/numbox~.c b/Source/Audio/numbox~.c
index c1aee6fc..caf1e398 100644
--- a/Source/Audio/numbox~.c
+++ b/Source/Audio/numbox~.c
@@ -5,6 +5,7 @@
 #include <g_canvas.h>
 #include <stdlib.h>
 #include <string.h>
+#include "g_all_guis.h"
 
 #define MINDIGITS      1
 #define MAX_NUMBOX_LEN 32
@@ -17,7 +18,7 @@ char def_font[100] = "DejaVu Sans Mono";
 #endif
 
 typedef struct _numbox{
-    t_object  x_obj;
+    t_iemgui  x_gui;
     t_clock  *x_clock_update;
     t_symbol *x_fg;
     t_symbol *x_bg;
@@ -50,6 +51,8 @@ typedef struct _numbox{
     char      x_tag_all[128];
 }t_numbox;
 
+#define x_obj x_gui.x_obj
+
 static t_class *numbox_class;
 t_widgetbehavior numbox_widgetbehavior;
 
@@ -72,6 +75,40 @@ char *set_x_buf(t_numbox *x){
     return(x->x_buf);
 }
 
+static void numbox_draw_update(t_numbox *x, t_glist *glist) { post("update"); }
+static void numbox_draw_move(t_numbox *x, t_glist *glist) { post("move"); }
+static void numbox_draw_new(t_numbox *x, t_glist *glist) { 
+    t_canvas *canvas=glist_getcanvas(glist);
+    int x1=text_xpix(&x->x_obj, glist);
+    int y1=text_ypix(&x->x_obj, glist);
+    int x2 = x1 + x->x_width, y2 = y1 + x->x_height;
+
+    gui_vmess("gui_numbox_new", "xxxxsiiiiii",
+        canvas,
+        x->x_gui.x_glist,
+        x->x_gui.x_glist->gl_owner,
+        x,
+        x->x_gui.x_bcol->s_name,
+        x1,
+        y1,
+        x2 - x1,
+        y2 - y1,
+        3,
+        glist_istoplevel(glist));
+
+    gui_vmess("gui_numbox_draw_text", "xxsisiiiiii",
+        canvas,
+        x,
+        set_x_buf(x),
+        x->x_gui.x_fontsize,
+        x->x_gui.x_fcol->s_name,
+        x1+2, y1, x1, y1,
+        x->x_height - 6 - x->x_gui.x_fontsize,
+        glist_istoplevel(x->x_gui.x_glist));
+}
+static void numbox_draw_select(t_numbox *x, t_glist *glist) { post("select"); }
+static void numbox_draw_config(t_numbox *x, t_glist *glist) { post("config"); }
+
 static void numbox_update_number(t_numbox *x){ // update number value
     if(glist_isvisible(x->x_glist) && gobj_shouldvis((t_gobj *)x, x->x_glist)){
         if(x->x_clicked && x->x_buf[0] && x->x_outmode){ // keyboard input values
@@ -230,8 +267,12 @@ static void numbox_range(t_numbox *x, t_floatarg f1, t_floatarg f2){
 }
 
 // ------------------------ widgetbehaviour-----------------------------
+#ifdef PDL2ORK
+static void numbox_key(void *z, t_floatarg fkey){
+#else
 static void numbox_key(void *z, t_symbol *keysym, t_floatarg fkey){
     keysym = NULL; // unused, avoid warning
+#endif
     t_numbox *x = z;
     char c = fkey, buf[3];
     buf[1] = 0;
@@ -265,6 +306,7 @@ static void numbox_key(void *z, t_symbol *keysym, t_floatarg fkey){
 
 static void numbox_motion(t_numbox *x, t_floatarg dx, t_floatarg dy, t_floatarg up){
     dx = 0; // avoid warning
+    post("motion");
     if(!up) // only when mouse is pressed down
         numbox_float(x, numbox_clip(x, x->x_out_val - dy*x->x_inc));
 }
@@ -283,6 +325,7 @@ static int numbox_newclick(t_gobj *z, struct _glist *glist, int xpix, int ypix,
         x->x_buf[0] = 0;
         pdgui_vmess(0, "crs ri", x->x_cv, "itemconfigure", x->x_tag_base,
             "-width", x->x_zoom*2);
+        
         glist_grab(glist, &x->x_obj.te_g, (t_glistmotionfn)numbox_motion, numbox_key,
             (t_floatarg)xpix, (t_floatarg)ypix);
     }
@@ -324,6 +367,15 @@ static void numbox_displace(t_gobj *z, t_glist *glist, int dx, int dy){
     canvas_fixlinesfor(glist, (t_text*)x);
 }
 
+static void numbox_draw(t_numbox *x, t_glist *glist, int mode)
+{
+    if(mode == IEM_GUI_DRAW_MODE_UPDATE)      sys_queuegui(x, glist, numbox_draw_update);
+    else if(mode == IEM_GUI_DRAW_MODE_MOVE)   numbox_draw_move(x, glist);
+    else if(mode == IEM_GUI_DRAW_MODE_NEW)    numbox_draw_new(x, glist);
+    else if(mode == IEM_GUI_DRAW_MODE_SELECT) numbox_draw_select(x, glist);
+    else if(mode == IEM_GUI_DRAW_MODE_CONFIG) numbox_draw_config(x, glist);
+}
+
 void numbox_vis(t_gobj *z, t_glist *glist, int vis){
     t_numbox* x = (t_numbox*)z;
     if(vis){ // draw
@@ -576,6 +628,28 @@ static void *numbox_new(t_symbol *s, int ac, t_atom *av){
     sprintf(x->x_tag_all, "%pALL", x);
     sprintf(x->x_tag_base, "%pBASE", x);
     outlet_new(&x->x_obj, &s_signal);
+
+#ifdef PDL2ORK
+    x->x_zoom = 1;
+    x->x_gui.x_bcol = x->x_bg;
+    x->x_gui.x_fcol = x->x_fg;
+    x->x_gui.x_lcol = gensym("#000000FF");
+    x->x_gui.x_click = 1;
+    x->x_gui.x_draw = (t_iemfunptr)numbox_draw;
+    iemgui_new_getnames(&x->x_gui, 6, 0);
+    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
+    x->x_gui.x_ldx = 0;
+    x->x_gui.x_ldy = 0;
+    x->x_gui.x_fontsize = x->x_fontsize;
+    x->x_gui.x_w = x->x_numwidth;
+    x->x_gui.x_h = x->x_height;
+    x->x_obj.te_iemgui = 1;
+    x->x_gui.x_changed = 0;
+    x->x_gui.legacy_x = 0;
+    x->x_gui.legacy_y = 1;
+    post("%p: %p", x, x->x_obj.te_g.g_pd);
+#endif
+
     return(x);
 errstate:
     pd_error(x, "[numbox~]: improper args");
@@ -598,6 +672,11 @@ void numbox_tilde_setup(void){
     class_addmethod(numbox_class, (t_method)numbox_fg, gensym("fgcolor"), A_GIMME, 0);
     class_addmethod(numbox_class, (t_method)numbox_zoom, gensym("zoom"), A_CANT, 0);
     class_addmethod(numbox_class, (t_method)numbox_dialog, gensym("dialog"), A_GIMME, 0);
+#ifdef PDL2ORK
+    wb_init(&numbox_widgetbehavior, numbox_getrect, numbox_newclick);
+    // iemgui_class_addmethods(numbox_class);
+    // class_addmethod(numbox_class, (t_method)iemgui_init, gensym("init"), A_FLOAT, 0);
+#else
     numbox_widgetbehavior.w_getrectfn  = numbox_getrect;
     numbox_widgetbehavior.w_displacefn = numbox_displace;
     numbox_widgetbehavior.w_selectfn   = numbox_select;
@@ -605,6 +684,7 @@ void numbox_tilde_setup(void){
     numbox_widgetbehavior.w_clickfn    = numbox_newclick;
     numbox_widgetbehavior.w_visfn      = numbox_vis;
     numbox_widgetbehavior.w_activatefn = NULL;
+#endif
     class_setwidget(numbox_class, &numbox_widgetbehavior);
     class_setsavefn(numbox_class, numbox_save);
     class_setpropertiesfn(numbox_class, numbox_properties);
diff --git a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h
index 21dc029b..7561af55 100644
--- a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h
+++ b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/atomic_queue.h
@@ -391,13 +391,21 @@ class AtomicQueue2 : public AtomicQueueCommon<AtomicQueue2<T, SIZE, MINIMIZE_CON
 
     T do_pop(unsigned tail) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(tail % size_);
+#ifdef PDL2ORK
+        return Base::do_pop_any(states_[index], elements_[index]);
+#else
         return Base::template do_pop_any(states_[index], elements_[index]);
+#endif
     }
 
     template<class U>
     void do_push(U&& element, unsigned head) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(head % size_);
+#ifdef PDL2ORK
+        Base::do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#else
         Base::template do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#endif
     }
 
 public:
@@ -519,13 +527,21 @@ class AtomicQueueB2 : public AtomicQueueCommon<AtomicQueueB2<T, A, MAXIMIZE_THRO
 
     T do_pop(unsigned tail) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(tail & (size_ - 1));
+#ifdef PDL2ORK
+        return Base::do_pop_any(states_[index], elements_[index]);
+#else
         return Base::template do_pop_any(states_[index], elements_[index]);
+#endif
     }
 
     template<class U>
     void do_push(U&& element, unsigned head) noexcept {
         unsigned index = details::remap_index<SHUFFLE_BITS>(head & (size_ - 1));
+#ifdef PDL2ORK
+        Base::do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#else
         Base::template do_push_any(std::forward<U>(element), states_[index], elements_[index]);
+#endif
     }
 
 public:
diff --git a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h
index a279dcf8..35e72846 100644
--- a/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h
+++ b/Source/Audio/sfz~/sfizz/library/external/atomic_queue/include/atomic_queue/defs.h
@@ -36,6 +36,15 @@ static inline void spin_loop_pause() noexcept {
 #endif
 }
 } // namespace atomic_queue
+#elif defined(__EMSCRIPTEN__)
+#include <emscripten.h>
+namespace atomic_queue {
+constexpr int CACHE_LINE_SIZE = 64;
+static inline void spin_loop_pause() noexcept {
+    // Yield to allow other pthreads in WebAssembly to run.
+    emscripten_sleep(0);
+}
+} // namespace atomic_queue
 #else
 #error "Unknown CPU architecture."
 #endif
diff --git a/Source/Shared/ffmpeg/build_ffmpeg.sh b/Source/Shared/ffmpeg/build_ffmpeg.sh
index 20ea0216..9f0a1281 100755
--- a/Source/Shared/ffmpeg/build_ffmpeg.sh
+++ b/Source/Shared/ffmpeg/build_ffmpeg.sh
@@ -17,7 +17,7 @@ elif [[ "$OS" == "Linux" ]]; then
         ffmpeg_config="--enable-openssl --enable-pic"
         ffmpeg_cc="${CC:-gcc}"
     fi
-elif [ "$(expr substr $(uname -s) 1 10)" == "MINGW64_NT" ]; then
+elif [ "$(expr substr $(uname -s) 1 5)" == "MINGW" ]; then
     ffmpeg_cc="${CC:-gcc}"
 else
     echo "Unsupported OS: $OS"
diff --git a/Source/Shared/link/udp/udp_socket.hpp b/Source/Shared/link/udp/udp_socket.hpp
index 2e447d2a..ab37ef80 100644
--- a/Source/Shared/link/udp/udp_socket.hpp
+++ b/Source/Shared/link/udp/udp_socket.hpp
@@ -11,7 +11,9 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #undef min
+#ifndef PDL2ORK
 typedef SSIZE_T ssize_t;
+#endif
 // Unix
 #else
 #include <sys/types.h>
